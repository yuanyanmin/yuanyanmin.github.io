---
title: 算法 18-12-28
date: 2018-12-28 13:16:53
tags: 算法
categories: 刷题
toc:
---

每日编程题：前正后负

题目描述：

一个长度为 n 的数组由负数、 0、 正数组成，编写函数，将其重新排序前段为负数，后段均为非负数的结构。要求时间复杂度为 O(n).

<!--more-->

**解法一：**

```
/*
 * 时间复杂度： O(n)
 * 空间复杂度： O(n)
 */
 /* 
#include <iostream>
using namespace std;

const int n = 10;

int main(){
	
	int a[n] = {1,2,-4,5,-9,0,-1,3,-2,7};
	int b[n];
	
	for(int i = 0,j = 0,p = 0;i<n;i++){
		if(a[i] < 0){
			b[j++] = a[i];
		}else if(a[i] >= 0){
			b[n-1-p] = a[i];
			p++;
		}
	}
	for(int i = 0;i<n;i++){
		cout<<a[i]<<":"<<b[i]<<endl;
	} 
	return 0;
} 
```



**解法二：**

```
/*
 * 时间复杂度： O(n)
 * 空间复杂度： O(1)
 */
 
 /*
 	思路：
	 使用两个指针，分别指向头和尾。
	 从前向后遍历顺序表，
	 如果该结点为负数，将其与头进行交换，头指针指向下一节点，从交换前的后一结点开始遍历
	 如果该结点为 0，则什么都不做，继续遍历
	 如果该结点为正数，将其与尾指针进行交换，尾指针指向前一结点，从交换前的结点指针处开始遍历 
 */ 
 
#include <iostream>
using namespace std;

void swap(int *a,int *b){
	int temp = *a;
	*a = *b;
	*b = temp;
}

void Sort(int a[],int length){
	int head = 0,rear = length - 1,count = 0;
	
	for(int i = head;count < length;){
		if(a[i] > 0) {
			swap(&a[i],&a[rear]);
			rear --;
			count ++;
		}
		if(a[i] == 0){
			i++;
			count++;
		}
		if(a[i] < 0){
			swap(&a[i],&a[head]);
			head++;
			count++;
			i++;
		}
	}
	
} 

int main(){
	int a[10] = {1,2,-4,5,-9,0,-1,3,-2,7};
	Sort(a,10);
	for(int i = 0;i<10;i++){
		cout<<a[i]<<" ";
	} 
	return 0;
} 
```

**补充：**

指针的值传递与地址传递

值传递：形参是实参的拷贝，改变形参并不会影响外部实参的值。从被调用函数角度来说，值传递是单向的（实参 --> 形参），参数的值只能传入，不能传出。当函数内部需要改变参数，并且不希望这个改变影响调用者时，采用值传递。

指针传递：形参为执行实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作

指针传递的实质：指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（实参指针本身的地址值不会变）。

